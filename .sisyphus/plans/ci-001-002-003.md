# CI-001, CI-002, CI-003: Wire Schedule, Add Notifications, Centralize Styles

## TL;DR

> **Quick Summary**: Implement three trivial code improvements: wire the existing schedule command to CLI, add desktop notifications to CLI backup, and consolidate TUI styles using the centralized Styles struct.
> 
> **Deliverables**:
> - `ScheduleCommand` wrapper function + CLI integration
> - `--notify` flag for backup command with SendSuccess/SendError calls
> - Centralized style usage across 5 TUI views + 3 new style definitions
> 
> **Estimated Effort**: Small (4-6 hours total)
> **Parallel Execution**: YES - 2 waves (CI-001 || CI-002, then CI-003)
> **Critical Path**: Task 1 → Task 4 (schedule) | Task 2 → Task 4 (notify) | Task 3 → Task 4 (styles)

---

## Context

### Original Request
Analyze IDEATION_CODE_IMPROVEMENTS.md and plan implementation of CI-001, CI-002, CI-003 (three trivial-effort improvements).

### Interview Summary
**Key Findings**:
- CI-001: `ScheduleCommand` wrapper **DOES NOT EXIST** (contrary to IDEATION assumption) - must be created
- CI-002: `notify.SendSuccess/SendError` ready to use, matches BackupResult fields exactly
- CI-003: 5 views have inline styles, need 3 new styles (Label, Value, Hint), color mismatch to resolve

**Research Findings**:
- ConfigCommand (config.go:14-54) provides exact pattern for subcommand routing
- notify.Send() gracefully handles missing notify-send (returns nil, not error)
- DefaultStyles uses #00FF00/#FF0000, views use #04B575/#FF5555 - need alignment

### Metis Review
**Identified Gaps** (addressed):
- ScheduleCommand doesn't exist: Plan includes creating it following ConfigCommand pattern
- Color mismatch: Will update DefaultStyles to match existing view colors (#04B575, #FF5555)
- Edge case handling: Schedule with no/invalid subcommand handled via usage output
- TextInput styling exception: settings.go cursor styles are component config, not view styling (excluded)

---

## Work Objectives

### Core Objective
Complete three trivial code improvements that leverage existing patterns and infrastructure.

### Concrete Deliverables
- `internal/cli/schedule.go`: Add `ScheduleCommand(args []string) int` function
- `cmd/dotkeeper/main.go`: Add "schedule" case + help text
- `internal/cli/backup.go`: Add `--notify` flag and notification calls
- `internal/tui/styles.go`: Add Label, Value, Hint styles; update Success/Error colors
- `internal/tui/views/*.go`: Replace inline styles with centralized usage (5 files)

### Definition of Done
- [x] `./bin/dotkeeper schedule status` runs without crash
- [x] `./bin/dotkeeper --help` shows schedule command
- [x] `./bin/dotkeeper backup --help` shows --notify flag
- [x] `grep -c "lipgloss.NewStyle" internal/tui/views/dashboard.go` returns 0
- [x] `make test` passes with no regressions

### Must Have
- ScheduleCommand routes to enable/disable/status subcommands
- --notify flag defaults to config.Notifications value
- Notification calls placed AFTER console output (not instead of)
- All inline title/help/error/success styles replaced in views

### Must NOT Have (Guardrails)
- DO NOT modify EnableSchedule/DisableSchedule/StatusSchedule implementations
- DO NOT fix contrib/systemd/ path resolution (out of scope - documented limitation)
- DO NOT add notifications to restore/list/config commands
- DO NOT let notification failures affect exit code
- DO NOT change view logic while updating styles
- DO NOT modify Update() or Init() methods
- DO NOT create theme switching or style parameters to constructors
- DO NOT replace textinput cursor styles (component config, not view styling)

---

## Verification Strategy

> **UNIVERSAL RULE: ZERO HUMAN INTERVENTION**
>
> ALL tasks in this plan MUST be verifiable WITHOUT any human action.

### Test Decision
- **Infrastructure exists**: YES (25 test files)
- **Automated tests**: Tests-after (verify with existing e2e + unit tests)
- **Framework**: `go test` via `make test`

### Agent-Executed QA Scenarios (MANDATORY — ALL tasks)

**Verification Tool by Deliverable Type:**

| Type | Tool | How Agent Verifies |
|------|------|-------------------|
| CLI commands | Bash | Run command, check exit code, grep output |
| TUI views | Bash (grep) | Count inline styles, verify imports |
| Tests | Bash | Run `make test`, assert pass |

---

## Execution Strategy

### Parallel Execution Waves

```
Wave 1 (Start Immediately):
├── Task 1: CI-001 Wire Schedule Command [no dependencies]
└── Task 2: CI-002 Add Notifications to CLI Backup [no dependencies]

Wave 2 (After Wave 1):
└── Task 3: CI-003 Centralize TUI Styles [no dependencies, but logical order]

Wave 3 (After Wave 2):
└── Task 4: Final Verification & Test Suite [depends: 1, 2, 3]

Critical Path: Any of Task 1/2/3 → Task 4
Parallel Speedup: ~30% faster than sequential
```

### Dependency Matrix

| Task | Depends On | Blocks | Can Parallelize With |
|------|------------|--------|---------------------|
| 1 | None | 4 | 2 |
| 2 | None | 4 | 1 |
| 3 | None | 4 | - |
| 4 | 1, 2, 3 | None | None (final) |

### Agent Dispatch Summary

| Wave | Tasks | Recommended Agents |
|------|-------|-------------------|
| 1 | 1, 2 | delegate_task(category="quick", load_skills=[], run_in_background=false) |
| 2 | 3 | delegate_task(category="quick", load_skills=[], run_in_background=false) |
| 3 | 4 | delegate_task(category="quick", load_skills=[], run_in_background=false) |

---

## TODOs

- [x] 1. CI-001: Wire Schedule Command to CLI

  **What to do**:
  1. Create `ScheduleCommand(args []string) int` function in `internal/cli/schedule.go`:
     - Parse args with `flag.NewFlagSet("schedule", flag.ExitOnError)`
     - Define Usage showing `dotkeeper schedule [enable|disable|status]`
     - Check `fs.NArg() < 1` → show usage, return 1
     - Switch on `fs.Arg(0)`:
       - `"enable"` → call `EnableSchedule()`, return 0/1 based on error
       - `"disable"` → call `DisableSchedule()`, return 0/1 based on error
       - `"status"` → call `StatusSchedule()`, return 0/1 based on error
       - `default` → print "Unknown subcommand", show usage, return 1
  2. Add case to `cmd/dotkeeper/main.go` switch statement (after line 53):
     ```go
     case "schedule":
         exitCode = cli.ScheduleCommand(args)
     ```
  3. Update `printHelp()` in main.go:
     - Add `schedule     Manage automated backup scheduling` to Commands section
     - Add example: `dotkeeper schedule enable`

  **Must NOT do**:
  - Modify EnableSchedule/DisableSchedule/StatusSchedule implementations
  - Fix contrib/systemd/ path resolution (document as limitation)
  - Add schedule configuration options

  **Recommended Agent Profile**:
  - **Category**: `quick`
    - Reason: Single file change + trivial main.go update, follows exact existing pattern
  - **Skills**: `[]`
    - No special skills needed - straightforward Go code following existing patterns

  **Parallelization**:
  - **Can Run In Parallel**: YES
  - **Parallel Group**: Wave 1 (with Task 2)
  - **Blocks**: Task 4
  - **Blocked By**: None (can start immediately)

  **References**:

  **Pattern References**:
  - `internal/cli/config.go:14-54` - EXACT subcommand routing pattern to follow (flag.NewFlagSet, NArg check, switch on Arg(0))
  - `cmd/dotkeeper/main.go:45-61` - Switch statement pattern for command routing

  **Implementation References**:
  - `internal/cli/schedule.go:15-80` - EnableSchedule() implementation
  - `internal/cli/schedule.go:82-124` - DisableSchedule() implementation
  - `internal/cli/schedule.go:126-155` - StatusSchedule() implementation

  **Documentation References**:
  - `cmd/dotkeeper/main.go:66-88` - printHelp() format to match

  **WHY Each Reference Matters**:
  - `config.go:14-54`: Shows exact pattern for subcommand handler - flag parsing, usage, subcommand switch
  - `main.go:45-61`: Shows where and how to add new command case
  - `schedule.go` functions: Already implemented, just need wrapper to route to them

  **Acceptance Criteria**:

  **Agent-Executed QA Scenarios:**

  ```
  Scenario: Schedule help displays available subcommands
    Tool: Bash
    Preconditions: Binary built at ./bin/dotkeeper
    Steps:
      1. Run: ./bin/dotkeeper schedule --help 2>&1
      2. Assert: Output contains "enable"
      3. Assert: Output contains "disable"
      4. Assert: Output contains "status"
      5. Assert: Exit code 0 or 2 (help may use either)
    Expected Result: Help text shows all three subcommands
    Evidence: Command output captured

  Scenario: Schedule with no subcommand shows usage
    Tool: Bash
    Preconditions: Binary built at ./bin/dotkeeper
    Steps:
      1. Run: ./bin/dotkeeper schedule 2>&1
      2. Assert: Output contains "Usage" or "enable|disable|status"
      3. Assert: Exit code 1 (no subcommand is error)
    Expected Result: Usage displayed, non-zero exit
    Evidence: Command output captured

  Scenario: Schedule status handles not-installed gracefully
    Tool: Bash
    Preconditions: Binary built, systemd timer NOT installed
    Steps:
      1. Run: ./bin/dotkeeper schedule status 2>&1
      2. Assert: Output contains "not active" OR "not installed" OR "timer"
      3. Assert: Exit code 0 (graceful handling)
    Expected Result: Informative message, no crash
    Evidence: Command output captured

  Scenario: Schedule invalid subcommand errors
    Tool: Bash
    Preconditions: Binary built at ./bin/dotkeeper
    Steps:
      1. Run: ./bin/dotkeeper schedule foo 2>&1
      2. Assert: Output contains "Unknown subcommand" OR "Usage"
      3. Assert: Exit code 1
    Expected Result: Error message with usage hint
    Evidence: Command output captured

  Scenario: Main help includes schedule command
    Tool: Bash
    Preconditions: Binary built at ./bin/dotkeeper
    Steps:
      1. Run: ./bin/dotkeeper --help
      2. Assert: Output contains "schedule"
      3. Assert: Output contains "scheduling" OR "automated"
    Expected Result: Schedule command listed in main help
    Evidence: Command output captured
  ```

  **Evidence to Capture:**
  - [ ] All command output from QA scenarios

  **Commit**: YES
  - Message: `feat(cli): wire schedule command for systemd timer management`
  - Files: `internal/cli/schedule.go`, `cmd/dotkeeper/main.go`
  - Pre-commit: `make test`

---

- [x] 2. CI-002: Add Notifications to CLI Backup

  **What to do**:
  1. Add import to `internal/cli/backup.go`:
     ```go
     "github.com/diogo/dotkeeper/internal/notify"
     ```
  2. Add `--notify` flag after line 16 (after passwordFile flag):
     ```go
     // Note: notifyFlag must be defined AFTER config is loaded to use config.Notifications as default
     ```
  3. Restructure to load config first, then define notify flag with config default:
     - Move config loading before flag definition
     - `notifyFlag := fs.Bool("notify", cfg.Notifications, "Send desktop notifications on completion")`
  4. Add notification calls:
     - After line 66 (success print block): `if *notifyFlag { notify.SendSuccess(result.BackupName, result.Duration) }`
     - After line 56 (backup failed): `if *notifyFlag { notify.SendError(err) }`
  5. Optionally add notification on other error paths (config load, validation, password) - but these are pre-backup errors, not backup failures. Decision: Only notify on backup attempt outcomes (success or actual backup failure).

  **Must NOT do**:
  - Let notification failure affect exit code
  - Add notifications to restore/list/config commands
  - Add --json notification output
  - Add webhook/alternative notification backends

  **Recommended Agent Profile**:
  - **Category**: `quick`
    - Reason: Single file modification, adding 2 function calls and 1 flag
  - **Skills**: `[]`
    - No special skills needed

  **Parallelization**:
  - **Can Run In Parallel**: YES
  - **Parallel Group**: Wave 1 (with Task 1)
  - **Blocks**: Task 4
  - **Blocked By**: None (can start immediately)

  **References**:

  **Pattern References**:
  - `internal/cli/backup.go:15-24` - Existing flag definition pattern
  - `internal/cli/list.go:29` - Example of boolean flag with default

  **API References**:
  - `internal/notify/notify.go:25-29` - SendSuccess(backupName string, duration time.Duration) signature
  - `internal/notify/notify.go:32-36` - SendError(err error) signature
  - `internal/backup/backup.go:16-25` - BackupResult struct with BackupName and Duration fields

  **Config References**:
  - `internal/config/config.go:18` - Notifications bool field
  - `internal/config/config.go:128` - Default value is true

  **WHY Each Reference Matters**:
  - `backup.go:15-24`: Shows how flags are currently defined (pattern to follow)
  - `notify.go`: Confirms function signatures match BackupResult fields
  - `config.go`: Shows Notifications field exists for flag default

  **Acceptance Criteria**:

  **Agent-Executed QA Scenarios:**

  ```
  Scenario: Backup help shows --notify flag
    Tool: Bash
    Preconditions: Binary built at ./bin/dotkeeper
    Steps:
      1. Run: ./bin/dotkeeper backup --help
      2. Assert: Output contains "--notify"
      3. Assert: Output contains "notification" (case-insensitive)
    Expected Result: Flag documented in help
    Evidence: Command output captured

  Scenario: Backup with notify flag succeeds
    Tool: Bash
    Preconditions: Binary built, valid config exists, password in env/keyring
    Steps:
      1. Set: DOTKEEPER_PASSWORD=testpassword123
      2. Run: ./bin/dotkeeper backup --notify 2>&1
      3. Assert: Output contains "Backup completed" OR "Backup failed" (either is valid)
      4. Note: Notification is best-effort, may not appear if notify-send missing
    Expected Result: Backup runs, notification attempted
    Evidence: Command output captured

  Scenario: Backup without notify flag also works
    Tool: Bash
    Preconditions: Binary built, valid config exists
    Steps:
      1. Set: DOTKEEPER_PASSWORD=testpassword123
      2. Run: ./bin/dotkeeper backup --notify=false 2>&1
      3. Assert: Output contains "Backup" (command runs)
    Expected Result: Backup runs without notification
    Evidence: Command output captured

  Scenario: Notify flag defaults to config value
    Tool: Bash
    Preconditions: Binary built
    Steps:
      1. Run: grep -A5 "notifyFlag" internal/cli/backup.go
      2. Assert: Output contains "cfg.Notifications" (uses config default)
    Expected Result: Flag default tied to config
    Evidence: Grep output captured
  ```

  **Evidence to Capture:**
  - [ ] All command output from QA scenarios

  **Commit**: YES
  - Message: `feat(cli): add --notify flag to backup command for desktop notifications`
  - Files: `internal/cli/backup.go`
  - Pre-commit: `make test`

---

- [x] 3. CI-003: Centralize TUI Styles in All Views

  **What to do**:
  1. Update `internal/tui/styles.go`:
     - Add `Label`, `Value`, `Hint` fields to Styles struct
     - Update `DefaultStyles()` to initialize new styles:
       - `Label`: `lipgloss.NewStyle().Bold(true)`
       - `Value`: `lipgloss.NewStyle().Foreground(lipgloss.Color("#AAAAAA"))`
       - `Hint`: `lipgloss.NewStyle().Foreground(lipgloss.Color("#666666")).Italic(true)`
     - Update existing colors for consistency:
       - `Success`: Change `#00FF00` to `#04B575` (matches existing view usage)
       - `Error`: Change `#FF0000` to `#FF5555` (matches existing view usage)

  2. Update `internal/tui/views/dashboard.go`:
     - Add import: No new import needed (tui package accessible via relative import? Check structure)
     - Actually: views package is separate, needs to import `github.com/diogo/dotkeeper/internal/tui`
     - In View(): Replace `titleStyle := lipgloss.NewStyle()...` with `styles := tui.DefaultStyles()` then use `styles.Title`

  3. Update `internal/tui/views/backuplist.go`:
     - Add import for tui package
     - In View(): Replace inline titleStyle, successStyle, errorStyle, helpStyle with centralized styles

  4. Update `internal/tui/views/restore.go`:
     - Add import for tui package
     - In View(): Replace inline titleStyle, helpStyle, errorStyle, statusStyle (Success) with centralized
     - Note: Keep countStyle and viewportStyle as-is (not in centralized styles, or add them)
     - Decision: Add `Count` style to DefaultStyles for consistency

  5. Update `internal/tui/views/settings.go`:
     - Add import for tui package
     - In View(): Replace inline titleStyle with centralized
     - Replace labelStyle with styles.Label, valueStyle with styles.Value
     - Replace selectedStyle with styles.Selected, hintStyle with styles.Hint
     - EXCEPTION: Keep textinput cursor/prompt styles (lines 32-33) - these are component config

  6. Update `internal/tui/views/logs.go`:
     - Add import for tui package
     - In View(): Replace inline titleStyle with centralized styles.Title

  **Must NOT do**:
  - Modify Update() or Init() methods
  - Change view logic while updating styles
  - Replace textinput cursor styles (component configuration)
  - Create theme switching or add style parameters to constructors
  - Change the visual appearance (colors should match what views already use)

  **Recommended Agent Profile**:
  - **Category**: `quick`
    - Reason: Mechanical replacement following clear pattern, no logic changes
  - **Skills**: `[]`
    - No special skills needed

  **Parallelization**:
  - **Can Run In Parallel**: NO (logically after CI-001/CI-002 for clean commits)
  - **Parallel Group**: Wave 2 (Sequential after Wave 1)
  - **Blocks**: Task 4
  - **Blocked By**: None technically, but ordered for clean git history

  **References**:

  **Pattern References**:
  - `internal/tui/styles.go:5-14` - Styles struct definition
  - `internal/tui/styles.go:16-40` - DefaultStyles() implementation pattern

  **Implementation References**:
  - `internal/tui/views/dashboard.go:53` - Inline titleStyle to replace
  - `internal/tui/views/backuplist.go:176-179` - Four inline styles to replace
  - `internal/tui/views/restore.go:451-454` - Four inline styles to replace
  - `internal/tui/views/settings.go:294-298` - Five inline styles to replace
  - `internal/tui/views/logs.go:40` - One inline style to replace

  **Color Mapping**:
  - Purple title: `#7D56F4` (keep)
  - Success green: `#04B575` (update from #00FF00)
  - Error red: `#FF5555` (update from #FF0000)
  - Help gray: `#666666` (keep)
  - Value gray: `#AAAAAA` (new)

  **WHY Each Reference Matters**:
  - `styles.go`: Shows exact struct and function to extend
  - View files: Shows exact lines with inline styles to replace
  - Color mapping: Ensures visual consistency maintained

  **Acceptance Criteria**:

  **Agent-Executed QA Scenarios:**

  ```
  Scenario: Dashboard has no inline lipgloss.NewStyle calls
    Tool: Bash
    Preconditions: Code changes applied
    Steps:
      1. Run: grep -c "lipgloss.NewStyle" internal/tui/views/dashboard.go
      2. Assert: Output is "0"
    Expected Result: Zero inline style definitions
    Evidence: Grep count captured

  Scenario: Backuplist has no inline lipgloss.NewStyle calls
    Tool: Bash
    Preconditions: Code changes applied
    Steps:
      1. Run: grep -c "lipgloss.NewStyle" internal/tui/views/backuplist.go
      2. Assert: Output is "0"
    Expected Result: Zero inline style definitions
    Evidence: Grep count captured

  Scenario: Logs has no inline lipgloss.NewStyle calls
    Tool: Bash
    Preconditions: Code changes applied
    Steps:
      1. Run: grep -c "lipgloss.NewStyle" internal/tui/views/logs.go
      2. Assert: Output is "0"
    Expected Result: Zero inline style definitions
    Evidence: Grep count captured

  Scenario: Settings retains only textinput styles
    Tool: Bash
    Preconditions: Code changes applied
    Steps:
      1. Run: grep -c "lipgloss.NewStyle" internal/tui/views/settings.go
      2. Assert: Output is "2" (cursor style + prompt style are allowed)
    Expected Result: Only component config styles remain
    Evidence: Grep count captured

  Scenario: Restore has minimal inline styles
    Tool: Bash
    Preconditions: Code changes applied
    Steps:
      1. Run: grep -c "lipgloss.NewStyle" internal/tui/views/restore.go
      2. Assert: Output is "1" or "2" (viewportStyle may remain if not centralized)
    Expected Result: Only non-standard styles remain
    Evidence: Grep count captured

  Scenario: New styles exist in styles.go
    Tool: Bash
    Preconditions: Code changes applied
    Steps:
      1. Run: grep "Label" internal/tui/styles.go
      2. Assert: Output contains "Label"
      3. Run: grep "Value" internal/tui/styles.go
      4. Assert: Output contains "Value"
      5. Run: grep "Hint" internal/tui/styles.go
      6. Assert: Output contains "Hint"
    Expected Result: All three new styles defined
    Evidence: Grep output captured

  Scenario: Success color updated
    Tool: Bash
    Preconditions: Code changes applied
    Steps:
      1. Run: grep -A2 "Success:" internal/tui/styles.go
      2. Assert: Output contains "#04B575"
    Expected Result: Success uses view-consistent color
    Evidence: Grep output captured

  Scenario: Error color updated
    Tool: Bash
    Preconditions: Code changes applied
    Steps:
      1. Run: grep -A2 "Error:" internal/tui/styles.go
      2. Assert: Output contains "#FF5555"
    Expected Result: Error uses view-consistent color
    Evidence: Grep output captured

  Scenario: Views import tui package
    Tool: Bash
    Preconditions: Code changes applied
    Steps:
      1. Run: grep "github.com/diogo/dotkeeper/internal/tui" internal/tui/views/dashboard.go
      2. Assert: Output contains the import
    Expected Result: tui package imported
    Evidence: Grep output captured
  ```

  **Evidence to Capture:**
  - [ ] All grep counts from QA scenarios

  **Commit**: YES
  - Message: `refactor(tui): centralize styles using DefaultStyles() across all views`
  - Files: `internal/tui/styles.go`, `internal/tui/views/dashboard.go`, `internal/tui/views/backuplist.go`, `internal/tui/views/restore.go`, `internal/tui/views/settings.go`, `internal/tui/views/logs.go`
  - Pre-commit: `make test`

---

- [x] 4. Final Verification & Test Suite

  **What to do**:
  1. Build the project: `make build`
  2. Run full test suite: `make test`
  3. Run all QA scenarios from Tasks 1-3 to verify end-to-end
  4. Verify no regressions in TUI (launch and navigate)

  **Must NOT do**:
  - Skip any verification step
  - Commit if tests fail

  **Recommended Agent Profile**:
  - **Category**: `quick`
    - Reason: Verification only, no code changes
  - **Skills**: `[]`
    - No special skills needed

  **Parallelization**:
  - **Can Run In Parallel**: NO
  - **Parallel Group**: Wave 3 (Final)
  - **Blocks**: None (final task)
  - **Blocked By**: Tasks 1, 2, 3

  **References**:
  - `Makefile` - Build and test targets
  - `e2e/e2e_cli_test.go` - Existing CLI tests

  **Acceptance Criteria**:

  **Agent-Executed QA Scenarios:**

  ```
  Scenario: Build succeeds
    Tool: Bash
    Preconditions: All code changes applied
    Steps:
      1. Run: make build
      2. Assert: Exit code 0
      3. Assert: ./bin/dotkeeper exists
    Expected Result: Binary built successfully
    Evidence: Build output captured

  Scenario: All tests pass
    Tool: Bash
    Preconditions: Build succeeded
    Steps:
      1. Run: make test
      2. Assert: Exit code 0
      3. Assert: Output contains "PASS" or "ok"
      4. Assert: Output does NOT contain "FAIL"
    Expected Result: Full test suite green
    Evidence: Test output captured

  Scenario: TUI launches without crash
    Tool: interactive_bash (tmux)
    Preconditions: Build succeeded
    Steps:
      1. tmux new-session: ./bin/dotkeeper
      2. Wait for: TUI renders (timeout: 5s)
      3. Send keys: "q" to quit
      4. Assert: Process exited cleanly
    Expected Result: TUI launches and exits cleanly
    Evidence: Terminal output captured

  Scenario: Schedule command accessible
    Tool: Bash
    Preconditions: Build succeeded
    Steps:
      1. Run: ./bin/dotkeeper schedule status
      2. Assert: Exit code 0 (graceful)
    Expected Result: Schedule command works
    Evidence: Command output captured

  Scenario: Backup help shows notify
    Tool: Bash
    Preconditions: Build succeeded
    Steps:
      1. Run: ./bin/dotkeeper backup --help | grep notify
      2. Assert: Exit code 0
    Expected Result: Notify flag visible
    Evidence: Command output captured
  ```

  **Commit**: NO (verification only)

---

## Commit Strategy

| After Task | Message | Files | Verification |
|------------|---------|-------|--------------|
| 1 | `feat(cli): wire schedule command for systemd timer management` | schedule.go, main.go | make test |
| 2 | `feat(cli): add --notify flag to backup command for desktop notifications` | backup.go | make test |
| 3 | `refactor(tui): centralize styles using DefaultStyles() across all views` | styles.go, 5 view files | make test |
| 4 | (no commit - verification only) | - | make test |

---

## Success Criteria

### Verification Commands
```bash
# CI-001: Schedule command works
./bin/dotkeeper schedule --help  # Shows subcommands
./bin/dotkeeper schedule status  # Runs without crash
./bin/dotkeeper --help | grep schedule  # Listed in help

# CI-002: Notifications added
./bin/dotkeeper backup --help | grep notify  # Flag visible

# CI-003: Styles centralized
grep -c "lipgloss.NewStyle" internal/tui/views/dashboard.go  # Returns 0
grep "Label" internal/tui/styles.go  # Style exists
grep "#04B575" internal/tui/styles.go  # Correct success color

# Overall: Tests pass
make test  # All pass
```

### Final Checklist
- [x] All "Must Have" present
- [x] All "Must NOT Have" absent
- [x] All tests pass
- [x] TUI launches without visual regressions
